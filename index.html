<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MatchMaster Pro - Advanced Fuzzy Matching</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .logo {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tagline {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            margin-bottom: 30px;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-box:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, #667eea10, #764ba210);
            transform: translateY(-2px);
        }

        .upload-box.dragover {
            border-color: #4CAF50;
            background: #4CAF5010;
        }

        .upload-box.file-loaded {
            border-color: #4CAF50;
            background: #4CAF5015;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .settings-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .settings-title {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #333;
            font-weight: 600;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
        }

        .setting-label {
            font-weight: 500;
            margin-bottom: 8px;
            color: #555;
        }

        .setting-input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .setting-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .weight-info {
            font-size: 0.8em;
            color: #888;
            margin-top: 4px;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-section {
            display: none;
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-weight: 500;
        }

        .results-section {
            display: none;
        }

        .results-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-title {
            font-size: 1.5em;
            color: #333;
            font-weight: 600;
        }

        .download-btn {
            background: #28a745;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .matches-preview {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .match-item {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 15px;
            padding: 15px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .match-item:last-child {
            border-bottom: none;
        }

        .match-source, .match-target {
            display: flex;
            flex-direction: column;
        }

        .match-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .match-artist {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 3px;
        }

        .match-writer {
            color: #888;
            font-size: 0.85em;
            font-style: italic;
        }

        .match-score {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #c3e6cb;
        }

        .footer {
            text-align: center;
            color: white;
            margin-top: 40px;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">üéØ MatchMaster Pro</div>
            <div class="tagline">Advanced Fuzzy Matching for Data Excellence</div>
        </div>

        <div class="main-card">
            <div class="upload-section">
                <div class="upload-box" id="internalUpload">
                    <div class="upload-icon">üìä</div>
                    <div class="upload-text">Upload Internal Catalog</div>
                    <div style="font-size: 0.9em; color: #999;">Drop Excel/CSV file here or click to browse</div>
                    <input type="file" class="file-input" id="internalFile" accept=".xlsx,.xls,.csv">
                    <div class="file-info" id="internalInfo" style="display: none;"></div>
                </div>

                <div class="upload-box" id="blackboxUpload">
                    <div class="upload-icon">üîç</div>
                    <div class="upload-text">Upload Black Box Data</div>
                    <div style="font-size: 0.9em; color: #999;">Drop Excel/CSV file here or click to browse</div>
                    <input type="file" class="file-input" id="blackboxFile" accept=".xlsx,.xls,.csv">
                    <div class="file-info" id="blackboxInfo" style="display: none;"></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">‚öôÔ∏è Matching Settings</div>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">Match Threshold (%)</label>
                        <input type="number" class="setting-input" id="threshold" value="50" min="0" max="100">
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Close Match Threshold (%)</label>
                        <input type="number" class="setting-input" id="closeThreshold" value="40" min="0" max="100">
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Title Weight</label>
                        <input type="number" class="setting-input" id="titleWeight" value="0.4" min="0" max="1" step="0.1">
                        <div class="weight-info">Importance of song title matching</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Artist Weight</label>
                        <input type="number" class="setting-input" id="artistWeight" value="0.35" min="0" max="1" step="0.1">
                        <div class="weight-info">Importance of artist matching</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Writer Weight</label>
                        <input type="number" class="setting-input" id="writerWeight" value="0.25" min="0" max="1" step="0.1">
                        <div class="weight-info">Importance of writer/songwriter matching</div>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="startMatching" disabled>
                    üöÄ Start Matching
                </button>
                <button class="btn btn-secondary" id="clearFiles">
                    üóëÔ∏è Clear Files
                </button>
            </div>

            <div class="progress-section" id="progressSection">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>

            <div id="errorMessage" class="error-message" style="display: none;"></div>
            <div id="successMessage" class="success-message" style="display: none;"></div>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-card">
                <div class="results-header">
                    <div class="results-title">üìà Matching Results</div>
                    <button class="download-btn" id="downloadBtn">
                        ‚¨áÔ∏è Download CSV
                    </button>
                </div>

                <div class="stats-grid" id="statsGrid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalMatches">0</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="highConfidence">0</div>
                        <div class="stat-label">High Confidence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="mediumConfidence">0</div>
                        <div class="stat-label">Medium Confidence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="averageScore">0%</div>
                        <div class="stat-label">Average Score</div>
                    </div>
                </div>

                <div class="matches-preview" id="matchesPreview"></div>
            </div>
        </div>

        <div class="footer">
            <p>¬© 2025 MatchMaster Pro - Powered by Advanced Fuzzy Matching Algorithms</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        class FuzzyMatcher {
            constructor() {
                this.internalData = null;
                this.blackboxData = null;
                this.matches = [];
                this.settings = {
                    threshold: 50,
                    closeThreshold: 40,
                    titleWeight: 0.4,
                    artistWeight: 0.35,
                    writerWeight: 0.25
                };
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // File upload handlers
                document.getElementById('internalFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e, 'internal');
                });

                document.getElementById('blackboxFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e, 'blackbox');
                });

                // Drag and drop handlers
                this.setupDragAndDrop('internalUpload', 'internal');
                this.setupDragAndDrop('blackboxUpload', 'blackbox');

                // Button handlers
                document.getElementById('startMatching').addEventListener('click', () => {
                    this.startMatching();
                });

                document.getElementById('clearFiles').addEventListener('click', () => {
                    this.clearFiles();
                });

                document.getElementById('downloadBtn').addEventListener('click', () => {
                    this.downloadResults();
                });

                // Settings change handlers
                ['threshold', 'closeThreshold', 'titleWeight', 'artistWeight', 'writerWeight'].forEach(id => {
                    document.getElementById(id).addEventListener('change', (e) => {
                        this.settings[id] = parseFloat(e.target.value);
                        this.validateWeights();
                    });
                });
            }

            validateWeights() {
                const totalWeight = this.settings.titleWeight + this.settings.artistWeight + this.settings.writerWeight;
                if (Math.abs(totalWeight - 1.0) > 0.01) {
                    console.warn(`Warning: Total weights sum to ${totalWeight.toFixed(2)}, consider adjusting for optimal results`);
                }
            }

            setupDragAndDrop(uploadBoxId, type) {
                const uploadBox = document.getElementById(uploadBoxId);
                const fileInput = document.getElementById(type + 'File');

                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                // Highlight drop area when item is dragged over it
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, () => {
                        uploadBox.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, () => {
                        uploadBox.classList.remove('dragover');
                    });
                });

                // Handle dropped files
                uploadBox.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFile(files[0], type);
                    }
                });

                // Handle click to browse
                uploadBox.addEventListener('click', (e) => {
                    // Don't trigger if clicking on the file input itself
                    if (e.target !== fileInput) {
                        fileInput.click();
                    }
                });
            }

            async handleFileUpload(event, type) {
                const file = event.target.files[0];
                if (!file) return;

                await this.processFile(file, type);
            }

            async processFile(file, type) {
                const fileInfo = document.getElementById(type + 'Info');
                const uploadBox = document.getElementById(type + 'Upload');
                
                this.hideMessages();

                try {
                    fileInfo.style.display = 'block';
                    fileInfo.innerHTML = `üìÑ Processing ${file.name} (${this.formatFileSize(file.size)})...`;

                    const data = await this.parseFile(file);
                    
                    if (!data || data.length === 0) {
                        throw new Error('No data found in file');
                    }

                    console.log(`[${type.toUpperCase()} FILE HEADERS]`, Object.keys(data[0]));

                    if (type === 'internal') {
                        this.internalData = data;
                    } else {
                        this.blackboxData = data;
                    }

                    fileInfo.innerHTML = `‚úÖ ${file.name} (${this.formatFileSize(file.size)}) - ${data.length} records loaded`;
                    uploadBox.classList.add('file-loaded');

                    this.updateStartButton();
                    this.showSuccess(`${type === 'internal' ? 'Internal Catalog' : 'Black Box Data'} loaded successfully: ${data.length} records`);

                } catch (error) {
                    console.error('File processing error:', error);
                    fileInfo.innerHTML = `‚ùå Error loading ${file.name}`;
                    uploadBox.classList.remove('file-loaded');
                    this.showError(`Error loading ${type} file: ${error.message}`);
                }
            }

            async parseFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            let data;
                            
                            if (file.name.toLowerCase().endsWith('.csv')) {
                                data = this.parseCSV(e.target.result);
                            } else if (file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
                                const workbook = XLSX.read(e.target.result, {type: 'array'});
                                const sheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[sheetName];
                                data = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                                data = this.convertArrayToObjects(data);
                            } else {
                                throw new Error('Unsupported file format. Please upload CSV or Excel files.');
                            }
                            
                            resolve(data);
                        } catch (error) {
                            console.error('Parse error:', error);
                            reject(error);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    
                    if (file.name.toLowerCase().endsWith('.csv')) {
                        reader.readAsText(file);
                    } else {
                        reader.readAsArrayBuffer(file);
                    }
                });
            }

            parseCSV(text) {
                const lines = text.split('\n').filter(line => line.trim());
                if (lines.length === 0) return [];
                
                const headers = this.parseCSVLine(lines[0]);
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = this.parseCSVLine(lines[i]);
                    if (values.length > 0) {
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index] || '';
                        });
                        data.push(row);
                    }
                }
                
                return data;
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current.trim());
                return result;
            }

            convertArrayToObjects(arrayData) {
                if (arrayData.length === 0) return [];
                
                const headers = arrayData[0].map(h => h ? h.toString().trim() : '');
                const data = [];
                
                for (let i = 1; i < arrayData.length; i++) {
                    const row = {};
                    let hasData = false;
                    
                    headers.forEach((header, index) => {
                        const value = arrayData[i][index] ? arrayData[i][index].toString().trim() : '';
                        row[header] = value;
                        if (value) hasData = true;
                    });
                    
                    if (hasData) {
                        data.push(row);
                    }
                }
                
                return data;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            updateStartButton() {
                const startBtn = document.getElementById('startMatching');
                startBtn.disabled = !this.internalData || !this.blackboxData;
            }

            clearFiles() {
                this.internalData = null;
                this.blackboxData = null;
                this.matches = [];
                
                // Reset file inputs
                document.getElementById('internalFile').value = '';
                document.getElementById('blackboxFile').value = '';
                
                // Hide file info
                document.getElementById('internalInfo').style.display = 'none';
                document.getElementById('blackboxInfo').style.display = 'none';
                
                // Remove visual indicators
                document.getElementById('internalUpload').classList.remove('file-loaded');
                document.getElementById('blackboxUpload').classList.remove('file-loaded');
                
                // Hide results
                document.getElementById('resultsSection').style.display = 'none';
                
                this.updateStartButton();
                this.hideMessages();
            }

            async startMatching() {
                this.showProgress();
                this.hideMessages();
                
                try {
                    await this.performMatching();
                    this.showResults();
                } catch (error) {
                    console.error('Matching error:', error);
                    this.showError(`Matching failed: ${error.message}`);
                } finally {
                    this.hideProgress();
                }
            }

            async performMatching() {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                progressText.textContent = 'Processing data...';
                progressFill.style.width = '10%';
                
                const matches = [];
                const totalComparisons = this.blackboxData.length;
                
                for (let i = 0; i < this.blackboxData.length; i++) {
                    const blackboxRecord = this.blackboxData[i];
                    let bestMatch = null;
                    let bestScore = 0;
                    
                    for (const internalRecord of this.internalData) {
                        const score = this.calculateMatchScore(blackboxRecord, internalRecord);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = internalRecord;
                        }
                    }
                    
                    if (bestScore >= this.settings.threshold) {
                        matches.push({
                            blackboxRecord,
                            internalRecord: bestMatch,
                            score: bestScore,
                            confidence: bestScore >= 80 ? 'high' : 'medium'
                        });
                    }
                    
                    // Update progress
                    const progress = ((i + 1) / totalComparisons) * 90 + 10;
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Matching records: ${i + 1}/${totalComparisons}`;
                    
                    // Allow UI to update
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                progressFill.style.width = '100%';
                progressText.textContent = 'Matching complete!';
                
                this.matches = matches;
            }

            calculateMatchScore(blackboxRecord, internalRecord) {
                // Get possible field names for title, artist, and writer
                const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
                const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
                const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
                
                const bbTitle = this.getFieldValue(blackboxRecord, titleFields);
                const bbArtist = this.getFieldValue(blackboxRecord, artistFields);
                const bbWriter = this.getFieldValue(blackboxRecord, writerFields);
                
                const intTitle = this.getFieldValue(internalRecord, titleFields);
                const intArtist = this.getFieldValue(internalRecord, artistFields);
                const intWriter = this.getFieldValue(internalRecord, writerFields);
                
                const titleScore = this.fuzzyMatch(bbTitle, intTitle);
                const artistScore = this.fuzzyMatch(bbArtist, intArtist);
                const writerScore = this.fuzzyMatch(bbWriter, intWriter);

                console.log({
                            bbTitle,
                            intTitle,
                            titleScore,
                            bbArtist,
                            intArtist,
                            artistScore,
                            bbWriter,
                            intWriter,
                            writerScore
                            });
                
                // Calculate weighted score
                const totalScore = (titleScore * this.settings.titleWeight) + 
                                 (artistScore * this.settings.artistWeight) + 
                                 (writerScore * this.settings.writerWeight);

                console.log({
                            bbTitle,
                            intTitle,
                            titleScore,
                            bbArtist,
                            intArtist,
                            artistScore,
                            bbWriter,
                            intWriter,
                            writerScore,
                            totalScore
                           });

                
                return Math.min(100, totalScore);
            }

            getFieldValue(record, possibleFields) {
                for (const field of possibleFields) {
                    if (record[field]) {
                        return this.cleanText(record[field]);
                    }
                }
                return '';
            }

            cleanText(text) {
                if (!text) return '';
                return text.toString()
                    .toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            fuzzyMatch(str1, str2) {
                if (!str1 || !str2) return 0;
                
                // Clean and normalize strings
                const s1 = this.cleanText(str1);
                const s2 = this.cleanText(str2);
                
                if (s1 === s2) return 100;
                
                // Calculate Levenshtein distance
                const distance = this.levenshteinDistance(s1, s2);
                const maxLength = Math.max(s1.length, s2.length);
                
                if (maxLength === 0) return 100;
                
                // Convert to similarity percentage
                const similarity = ((maxLength - distance) / maxLength) * 100;
                
                // Bonus for partial matches
                const wordsMatch = this.calculateWordMatches(s1, s2);
                const finalScore = Math.max(similarity, wordsMatch);
                
                return Math.min(100, finalScore);
            }

            levenshteinDistance(str1, str2) {
                const matrix = [];
                
                // Create matrix
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                // Fill matrix
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            calculateWordMatches(str1, str2) {
                const words1 = str1.split(' ').filter(w => w.length > 0);
                const words2 = str2.split(' ').filter(w => w.length > 0);
                
                if (words1.length === 0 || words2.length === 0) return 0;
                
                let matches = 0;
                const used = new Set();
                
                for (const word1 of words1) {
                    for (let i = 0; i < words2.length; i++) {
                        if (used.has(i)) continue;
                        
                        const word2 = words2[i];
                        const wordSimilarity = this.wordSimilarity(word1, word2);
                        
                        if (wordSimilarity > 0.8) {
                            matches++;
                            used.add(i);
                            break;
                        }
                    }
                }
                
                const totalWords = Math.max(words1.length, words2.length);
                return (matches / totalWords) * 100;
            }

            wordSimilarity(word1, word2) {
                if (word1 === word2) return 1;
                
                const distance = this.levenshteinDistance(word1, word2);
                const maxLength = Math.max(word1.length, word2.length);
                
                return (maxLength - distance) / maxLength;
            }

            showResults() {
                const resultsSection = document.getElementById('resultsSection');
                const statsGrid = document.getElementById('statsGrid');
                
                // Calculate statistics
                const totalMatches = this.matches.length;
                const highConfidence = this.matches.filter(m => m.confidence === 'high').length;
                const mediumConfidence = this.matches.filter(m => m.confidence === 'medium').length;
                const averageScore = totalMatches > 0 ? 
                    Math.round(this.matches.reduce((sum, m) => sum + m.score, 0) / totalMatches) : 0;
                
                // Update statistics
                document.getElementById('totalMatches').textContent = totalMatches;
                document.getElementById('highConfidence').textContent = highConfidence;
                document.getElementById('mediumConfidence').textContent = mediumConfidence;
                document.getElementById('averageScore').textContent = averageScore + '%';
                
                // Show preview of matches
                this.showMatchesPreview();
                
                // Show results section
                resultsSection.style.display = 'block';
                
                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth' });
                
                this.showSuccess(`Matching complete! Found ${totalMatches} matches with average score of ${averageScore}%`);
            }

            showMatchesPreview() {
                const preview = document.getElementById('matchesPreview');
                preview.innerHTML = '';
                
                if (this.matches.length === 0) {
                    preview.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No matches found above the threshold</div>';
                    return;
                }
                
                // Sort matches by score (highest first)
                const sortedMatches = this.matches.sort((a, b) => b.score - a.score);
                
                // Show top 50 matches in preview
                const previewMatches = sortedMatches.slice(0, 50);
                
                previewMatches.forEach((match, index) => {
                    const matchElement = document.createElement('div');
                    matchElement.className = 'match-item';
                    
                    const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
                    const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
                    const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
                    
                    const bbTitle = this.getFieldValue(match.blackboxRecord, titleFields) || 'N/A';
                    const bbArtist = this.getFieldValue(match.blackboxRecord, artistFields) || 'N/A';
                    const bbWriter = this.getFieldValue(match.blackboxRecord, writerFields) || 'N/A';
                    
                    const intTitle = this.getFieldValue(match.internalRecord, titleFields) || 'N/A';
                    const intArtist = this.getFieldValue(match.internalRecord, artistFields) || 'N/A';
                    const intWriter = this.getFieldValue(match.internalRecord, writerFields) || 'N/A';
                    
                    matchElement.innerHTML = `
                        <div class="match-source">
                            <div class="match-title">${this.escapeHtml(bbTitle)}</div>
                            <div class="match-artist">${this.escapeHtml(bbArtist)}</div>
                            <div class="match-writer">${this.escapeHtml(bbWriter)}</div>
                        </div>
                        <div class="match-target">
                            <div class="match-title">${this.escapeHtml(intTitle)}</div>
                            <div class="match-artist">${this.escapeHtml(intArtist)}</div>
                            <div class="match-writer">${this.escapeHtml(intWriter)}</div>
                        </div>
                        <div class="match-score">${Math.round(match.score)}%</div>
                    `;
                    
                    preview.appendChild(matchElement);
                });
                
                if (this.matches.length > 50) {
                    const moreElement = document.createElement('div');
                    moreElement.style.textAlign = 'center';
                    moreElement.style.padding = '20px';
                    moreElement.style.color = '#666';
                    moreElement.style.fontStyle = 'italic';
                    moreElement.textContent = `... and ${this.matches.length - 50} more matches. Download CSV for complete results.`;
                    preview.appendChild(moreElement);
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            downloadResults() {
                if (this.matches.length === 0) {
                    this.showError('No matches to download');
                    return;
                }
                
                // Create CSV content
                const headers = this.createCSVHeaders();
                const csvContent = [headers].concat(
                    this.matches.map(match => this.createCSVRow(match))
                ).join('\n');
                
                // Create and trigger download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', `fuzzy_matches_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    this.showSuccess('Results downloaded successfully!');
                } else {
                    this.showError('Download not supported in this browser');
                }
            }

            createCSVHeaders() {
                const headers = [
                    'Match Score',
                    'Confidence',
                    'BB Title',
                    'BB Artist', 
                    'BB Writer',
                    'Internal Title',
                    'Internal Artist',
                    'Internal Writer'
                ];
                
                // Add any additional fields from the data
                if (this.matches.length > 0) {
                    const bbFields = Object.keys(this.matches[0].blackboxRecord);
                    const intFields = Object.keys(this.matches[0].internalRecord);
                    
                    bbFields.forEach(field => {
                        if (!headers.includes('BB ' + field)) {
                            headers.push('BB ' + field);
                        }
                    });
                    
                    intFields.forEach(field => {
                        if (!headers.includes('Internal ' + field)) {
                            headers.push('Internal ' + field);
                        }
                    });
                }
                
                return headers.map(h => `"${h}"`).join(',');
            }

            createCSVRow(match) {
                const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
                const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
                const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
                
                const row = [
                    Math.round(match.score),
                    match.confidence,
                    this.getFieldValue(match.blackboxRecord, titleFields) || '',
                    this.getFieldValue(match.blackboxRecord, artistFields) || '',
                    this.getFieldValue(match.blackboxRecord, writerFields) || '',
                    this.getFieldValue(match.internalRecord, titleFields) || '',
                    this.getFieldValue(match.internalRecord, artistFields) || '',
                    this.getFieldValue(match.internalRecord, writerFields) || ''
                ];
                
                // Add additional fields
                Object.keys(match.blackboxRecord).forEach(field => {
                    row.push(match.blackboxRecord[field] || '');
                });
                
                Object.keys(match.internalRecord).forEach(field => {
                    row.push(match.internalRecord[field] || '');
                });
                
                return row.map(cell => `"${this.escapeCSV(cell)}"`).join(',');
            }

            escapeCSV(text) {
                if (!text) return '';
                return text.toString().replace(/"/g, '""');
            }

            showProgress() {
                document.getElementById('progressSection').style.display = 'block';
                document.getElementById('progressFill').style.width = '0%';
            }

            hideProgress() {
                document.getElementById('progressSection').style.display = 'none';
            }

            showError(message) {
                const errorElement = document.getElementById('errorMessage');
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 5000);
            }

            showSuccess(message) {
                const successElement = document.getElementById('successMessage');
                successElement.textContent = message;
                successElement.style.display = 'block';
                
                setTimeout(() => {
                    successElement.style.display = 'none';
                }, 5000);
            }

            hideMessages() {
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('successMessage').style.display = 'none';
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new FuzzyMatcher();
        });
    </script>
</body>
</html>
